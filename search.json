[{"title":"Arthas使用教程第二章","url":"/2022/04/18/Arthas%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0/","content":"<h1 id=\"Arthas-使用教程\"><a href=\"#Arthas-使用教程\" class=\"headerlink\" title=\"Arthas 使用教程\"></a>Arthas 使用教程</h1><h3 id=\"9、Ognl\"><a href=\"#9、Ognl\" class=\"headerlink\" title=\"9、Ognl\"></a>9、Ognl</h3><ol>\n<li><p>在Arthas中，可以动态执行代码</p>\n</li>\n<li><p>调用static 函数</p>\n<ol>\n<li>ognl ‘@java <a href=\"mailto:&#x2e;&#108;&#97;&#x6e;&#x67;&#46;&#83;&#121;&#x73;&#x74;&#101;&#109;&#x40;&#x6f;&#x75;&#x74;&#x2e;&#112;&#114;&#x69;&#110;&#x74;&#x6c;&#x6e;\">&#x2e;&#108;&#97;&#x6e;&#x67;&#46;&#83;&#121;&#x73;&#x74;&#101;&#109;&#x40;&#x6f;&#x75;&#x74;&#x2e;&#112;&#114;&#x69;&#110;&#x74;&#x6c;&#x6e;</a>(“hello ognl”)’;</li>\n<li>可以查看在自己代码终端打印了hello ognl</li>\n</ol>\n</li>\n<li><p>案例：</p>\n<ol>\n<li><p>查询usercontroller的ClassLoader, ,命令：&#x3D;&#x3D; sc -d packageName.className | grep classLoaderhash</p>\n</li>\n<li><p>通过ognl 命令执行打印的hash ， 命令：ognl hashValue</p>\n</li>\n<li><p>对于只有唯一实例的ClassLoader可以通过<code>--classLoaderClass</code>指定class name，使用起来更加方便 命令 ： ognl –classLoaderClass</p>\n</li>\n<li><p>获取静态类的静态字段</p>\n<ol>\n<li>获取<code>UserController</code>类里的<code>logger</code>字段：ognl –classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader @com.example.demo.arthas.user.UserController@logger</li>\n<li>-x : 可以控制返回值展开层数： ognl –classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -x 2 @com.example.demo.arthas.user.UserController@logger</li>\n</ol>\n</li>\n<li><p>执行多行表达式，赋值给临时变量，返回一个List：ognl ‘#value1&#x3D;@System@getProperty(“java.home”), #value2&#x3D;@System@getProperty(“java.runtime.name”), {&amp;#35;value1, &amp;#35;value2}’<br><img src=\"/../../../images/image-20211125112821287.png\" alt=\"image-20211125112821287\"></p>\n</li>\n<li><p><a href=\"https://github.com/alibaba/arthas/issues/71\">OGNL特殊用法参考</a></p>\n</li>\n<li><p><a href=\"https://commons.apache.org/proper/commons-ognl/language-guide.html\">OGNL表达式官方指南</a></p>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><h3 id=\"10、Web-Console\"><a href=\"#10、Web-Console\" class=\"headerlink\" title=\"10、Web Console\"></a>10、Web Console</h3><ol>\n<li>Arthas 支持通过WebSocket连接</li>\n</ol>\n<h3 id=\"11、arth-as-boot支持参数\"><a href=\"#11、arth-as-boot支持参数\" class=\"headerlink\" title=\"11、arth as-boot支持参数\"></a>11、arth as-boot支持参数</h3><p><code>arthas-boot.jar</code> 支持很多参数，可以执行 <code>java -jar arthas-boot.jar -h</code> 来查看。</p>\n<p>允许外部访问 </p>\n<ol>\n<li><p>默认情况下， arthas server侦听的是 <code>127.0.0.1</code> 这个IP，如果希望远程可以访问，可以使用<code>--target-ip</code>的参数。</p>\n<p>java -jar arthas-boot.jar –target-ip</p>\n<p><img src=\"/../../../images/image-20211125141804878.png\" alt=\"image-20211125141804878\"></p>\n</li>\n<li><p>列出所有版本</p>\n<p>java -jar arthas-boot.jar –versions</p>\n</li>\n<li><p>使用指定版本</p>\n<p>java -jar arthas-boot.jar –use-version 3.1.0</p>\n</li>\n<li><p>只监听Telnet端口 侦听Http端口</p>\n<p>java -jar arthas-boot.jar –telnet-port 9999 –http-port -1</p>\n</li>\n<li><p>打印运行的详情</p>\n<p>java -jar arthas-boot.jar -v</p>\n</li>\n</ol>\n<h3 id=\"12、介绍查看jvm信息命令\"><a href=\"#12、介绍查看jvm信息命令\" class=\"headerlink\" title=\"12、介绍查看jvm信息命令\"></a>12、介绍查看jvm信息命令</h3><ol>\n<li>sysprop: 可以打印所有的System Properties信息<ol>\n<li>也可以指定单个key ： sysprop java.version</li>\n<li>也可以通过grep来过滤：sysprop | grep user</li>\n<li>可以设置新的value：sysprop keyName keyvalue</li>\n</ol>\n</li>\n<li>sysenv :可以获取环境变量</li>\n<li>jvm： 打印jvm各种详细信息</li>\n<li>dashboard 查看当前系统的实时数据面板</li>\n<li>以上命令都可以通过按tab进行命令补全</li>\n<li>keymap：查看快捷键</li>\n<li>history：查看操作的所有的历史命令</li>\n</ol>\n<h3 id=\"13、arthas学习文档\"><a href=\"#13、arthas学习文档\" class=\"headerlink\" title=\"13、arthas学习文档\"></a>13、<a href=\"https://arthas.aliyun.com/doc/\">arthas学习文档</a></h3>","categories":["排错"],"tags":["Java"]},{"title":"Arthas使用教程第一章","url":"/2022/04/18/Arthas%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%E7%AC%AC%E4%B8%80%E7%AB%A0/","content":"<h1 id=\"Arthas-使用教程\"><a href=\"#Arthas-使用教程\" class=\"headerlink\" title=\"Arthas 使用教程\"></a>Arthas 使用教程</h1><h3 id=\"1、dashboard\"><a href=\"#1、dashboard\" class=\"headerlink\" title=\"1、dashboard\"></a>1、dashboard</h3><ol>\n<li>通过命令可以查看当前系统实时数据面板</li>\n<li>通过q或者ctrl + c可以退出dashboard 命令。</li>\n</ol>\n<h3 id=\"2、thead\"><a href=\"#2、thead\" class=\"headerlink\" title=\"2、thead\"></a>2、thead</h3><ol>\n<li>thread 1 命令会打印线程ID1的栈</li>\n<li>Archas 支持管道，可以通过thread 1 | grep ‘main(‘ 查询到main class ，</li>\n</ol>\n<h3 id=\"3、-sc\"><a href=\"#3、-sc\" class=\"headerlink\" title=\"3、 sc\"></a>3、 sc</h3><ol>\n<li>可以通过sc命令查询jvm里加载的类 &#x3D;&#x3D;sc -d *className&#x3D;&#x3D;</li>\n<li>-d : 打印出类加载的具体信息</li>\n<li>可以支持通配符查询</li>\n</ol>\n<h3 id=\"4、jad\"><a href=\"#4、jad\" class=\"headerlink\" title=\"4、jad\"></a>4、jad</h3><ol>\n<li>反编译代码</li>\n<li>–source-only ： 可以只打印在反编译的源代码</li>\n</ol>\n<h3 id=\"5、watch\"><a href=\"#5、watch\" class=\"headerlink\" title=\"5、watch\"></a>5、watch</h3><ol>\n<li>通过watch 命令实时可以查看函数参数&#x2F;返回值&#x2F;异常信息</li>\n<li>&#x3D;&#x3D;watch packageName.className methodName returnObj;&#x3D;&#x3D;</li>\n</ol>\n<h3 id=\"6、vmtool\"><a href=\"#6、vmtool\" class=\"headerlink\" title=\"6、vmtool\"></a>6、vmtool</h3><ol>\n<li>通过vmtool命令可以搜索内存对象</li>\n<li>&#x3D;&#x3D; vmtool –action getInstances –className java.lang.String – limit 10&#x3D;&#x3D;</li>\n</ol>\n<h3 id=\"7、Exit-x2F-stop\"><a href=\"#7、Exit-x2F-stop\" class=\"headerlink\" title=\"7、Exit&#x2F;stop\"></a>7、Exit&#x2F;stop</h3><ol>\n<li>退出Arthas，退出后可以再次使用java -jar archas.jar 连接</li>\n<li>彻底退出arthas exit&#x2F;quit 只是退出当前session，arthas server 还在目标进程中进行。想要完全退出Arthas 可以执行stop命令</li>\n</ol>\n<h3 id=\"8、sm\"><a href=\"#8、sm\" class=\"headerlink\" title=\"8、sm\"></a>8、sm</h3><ol>\n<li>sm命令查找类的具体函数 sm java.math.RoundingMode</li>\n<li>-d ： 打印函数的具体属性 sm -d java.math.RoundingMode</li>\n<li>也可以查询指定的函数 java.math.RoundingMode <init></li>\n</ol>\n","categories":["排错"],"tags":["Java"]},{"title":"Arthas案例分析","url":"/2022/04/18/Arthas%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/","content":"<h3 id=\"案例1-查询用户信息详情为例\"><a href=\"#案例1-查询用户信息详情为例\" class=\"headerlink\" title=\"案例1 [查询用户信息详情为例]\"></a>案例1 [查询用户信息详情为例]</h3><ol>\n<li><p>首先通过curl 访问接口服务地址</p>\n<p>curl 接口服务地址</p>\n<p>curl httl:&#x2F;&#x2F;localhost:8080&#x2F;user&#x2F;0</p>\n</li>\n<li><p>打开一个new terminal 使用watch命令</p>\n<p>watch packageName.UserController * ‘{params, throwExp}’;</p>\n<p>第一个参数是类型 支持通配</p>\n<p>第二个参数是函数名 支持通配</p>\n<p>访问接口服务地址 watch 命令会打印调用参数和异常</p>\n<p><img src=\"/../../../images/image-20211125120217655.png\" alt=\"image-20211125120217655\"></p>\n<p>可以看到实际抛出的异常是<code>IllegalArgumentException</code></p>\n<p>可以通过q或者ctrl+c退出watch命令模式</p>\n<p>如果想把获取的结果展开 可以用 <code>-x</code>参数：</p>\n<p><img src=\"/../../../images/image-20211125120456353.png\" alt=\"image-20211125120456353\"></p>\n</li>\n<li><p>返回值表达式</p>\n<ol>\n<li><p>第三个参数是<code>返回值表达式</code>，实际是一个ognl表达式，支持一些内置对象</p>\n<ol>\n<li>loader</li>\n<li>clazz</li>\n<li>method</li>\n<li>target</li>\n<li>params</li>\n<li>returnObj</li>\n<li>throwExp</li>\n<li>isBeore</li>\n<li>isThrow</li>\n<li>isReturn</li>\n</ol>\n<p>&#x3D;&#x3D; 可以利用这些内置对应对象组成不同表达式。&#x3D;&#x3D;</p>\n</li>\n<li><p>比如返回一个数组</p>\n<ol>\n<li>watch com.example.demo.arthas.user.UserController * ‘{params[0], target, returnObj}’</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>条件表达式</p>\n<ol>\n<li><p>watch 命令支持第4个参数写表达式</p>\n</li>\n<li><p>watch com.example.demo.arthas.user.UserController * returnObj ‘params[0] &gt; 100’</p>\n<p>curl httl:&#x2F;&#x2F;localhost:8080&#x2F;user&#x2F;1 watch没有检测结果</p>\n<p>curl httl:&#x2F;&#x2F;localhost:8080&#x2F;user&#x2F;101 watch会有如下输出</p>\n<p><img src=\"/../../../images/image-20211125121238734.png\" alt=\"image-20211125121238734\"></p>\n</li>\n</ol>\n</li>\n<li><p>异常时捕获</p>\n<ol>\n<li>watch 命令支持<code>-e</code>选项 表示只捕获抛出异常的请求</li>\n<li>命令：watch com.example.demo.arthas.user.UserController * “{params[0],throwExp}” -e</li>\n</ol>\n</li>\n<li><p>按照耗时进行过滤</p>\n<ol>\n<li>watch 命令支持按请求耗时进行过滤</li>\n<li>命令：watch com.example.demo.arthas.user.UserController * ‘{params, returnObj}’ ‘#cost&gt;200’</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"案例2-热更新代码\"><a href=\"#案例2-热更新代码\" class=\"headerlink\" title=\"案例2[热更新代码]\"></a>案例2[热更新代码]</h3><h4 id=\"下面通过jad-、-mc-、-redefine-命令实现动态更新代码的功能\"><a href=\"#下面通过jad-、-mc-、-redefine-命令实现动态更新代码的功能\" class=\"headerlink\" title=\"下面通过jad 、 mc 、 redefine 命令实现动态更新代码的功能\"></a>下面通过jad 、 mc 、 redefine 命令实现动态更新代码的功能</h4><p>情况分析：之前我们通过访问curl httl:&#x2F;&#x2F;localhost:8080&#x2F;user&#x2F;0 会出现一场情况。现在由于我们想避免这个异常且代码上线了我们如果去做呢？</p>\n<ol>\n<li><p>首先通过jad反编译UserCOntroller代码</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">jad --source-only com.example.demo.arthas.user.UserController &gt; /tmp/UserController.java</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>用编辑器打开<code>/tmp/UserOController</code>代码</p>\n<p>vim &#x2F;temp&#x2F;UserController，修改成如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GetMapping(value=&#123;&quot;/user/&#123;id&#125;&quot;&#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> User <span class=\"title function_\">findUserById</span><span class=\"params\">(<span class=\"meta\">@PathVariable</span> Integer id)</span> &#123;</span><br><span class=\"line\">    logger.info(<span class=\"string\">&quot;id: &#123;&#125;&quot;</span>, (Object)id);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (id != <span class=\"literal\">null</span> &amp;&amp; id &lt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">User</span>(id, <span class=\"string\">&quot;name&quot;</span> + id);</span><br><span class=\"line\">        <span class=\"comment\">// throw new IllegalArgumentException(&quot;id &lt; 1&quot;);</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">User</span>(id.intValue(), <span class=\"string\">&quot;name&quot;</span> + id);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>用sc查询加载UserController的ClassLoader</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">sc -d *UserController | grep classLoaderHash</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用<code>mc</code>(Memory Compiler)命令来编译，并且通过<code>-c</code>或者<code>--classLoaderClass</code>参数指定ClassLoader：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">mc --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader /tmp/UserController.java -d /tmp</span><br><span class=\"line\"></span><br><span class=\"line\">也可以通过`mc -c &lt;classLoaderHash&gt; /tmp/UserController.java -d /tmp`，使用`-c`参数指定ClassLoaderHash:</span><br><span class=\"line\"></span><br><span class=\"line\">mc -c 1be6f5c3 /tmp/UserController.java -d /tmp</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在使用redefine命令重新加载新编译好的</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">redefine /tmp/com/example/demo/arthas/user/UserController.class</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../../../images/image-20211125123026712.png\" alt=\"image-20211125123026712\"></p>\n</li>\n<li><p>成功后你在访问 curl httl:&#x2F;&#x2F;localhost:8080&#x2F;user&#x2F;0 就不会有问题了</p>\n</li>\n</ol>\n<h3 id=\"案例3-动态更新应用Logger-Level-单个更新某个控制层的和更新项目所有的\"><a href=\"#案例3-动态更新应用Logger-Level-单个更新某个控制层的和更新项目所有的\" class=\"headerlink\" title=\"案例3[动态更新应用Logger Level(单个更新某个控制层的和更新项目所有的)]\"></a>案例3[动态更新应用Logger Level(单个更新某个控制层的和更新项目所有的)]</h3><ol>\n<li><p>查询UserController的ClassLoader</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">sc -d com.example.demo.arthas.user.UserController | grep classLoaderHash</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../../../images/image-20211125123503066.png\" alt=\"image-20211125123503066\"></p>\n</li>\n<li><p>用ognl获取logger</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader &#x27;@com.example.demo.arthas.user.UserController@logger&#x27;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../../../images/image-20211125123619517.png\" alt=\"image-20211125123619517\"></p>\n<p>可以知道<code>UserController@logger</code>实际使用的是logback。可以看到<code>level=null</code>，则说明实际最终的level是从<code>root</code> logger里来的。</p>\n</li>\n<li><p>单独设置UserController的loggerLevel</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader &#x27;@com.example.demo.arthas.user.UserController@logger.setLevel(@ch.qos.logback.classic.Level@DEBUG)&#x27;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../../../images/image-20211125123815136.png\" alt=\"image-20211125123815136\"></p>\n</li>\n<li><p>修改全局的LoggerLevel</p>\n<p>通过获取<code>root</code> logger，可以修改全局的logger level：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader &#x27;@org.slf4j.LoggerFactory@getLogger(&quot;root&quot;).setLevel(@ch.qos.logback.classic.Level@DEBUG)&#x27;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"案例4-排除logger冲突问题\"><a href=\"#案例4-排除logger冲突问题\" class=\"headerlink\" title=\"案例4[排除logger冲突问题]\"></a>案例4[排除logger冲突问题]</h3><p>以<code>UserController</code>为例，它使用的是slf4j api，但实际使用到的logger系统是logback。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader &#x27;@com.example.demo.arthas.user.UserController@logger&#x27;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>获取logback实际加载的配置文件</p>\n<p>ognl –classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader ‘#map1&#x3D;@org.slf4j.LoggerFactory@getLogger(“root”).loggerContext.objectMap, #map1.get(“CONFIGURATION_WATCH_LIST”)’</p>\n<p><img src=\"/../../../images/image-20211125133400839.png\" alt=\"image-20211125133400839\"></p>\n</li>\n<li><p>使用classloader命令查询可能存在的logger配置文件</p>\n<p>classloader –classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -r logback-spring.xml</p>\n<p><img src=\"/../../../images/image-20211125133616701.png\" alt=\"image-20211125133616701\"></p>\n<p>可以试着加载容易冲突的文件</p>\n<p>classloader –classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -r logback.xml</p>\n<p>classloader –classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -r log4j.properties</p>\n<p><img src=\"/../../../images/image-20211125133806053.png\" alt=\"image-20211125133806053\"></p>\n</li>\n</ol>\n<h3 id=\"案例5-获取Spring-Context\"><a href=\"#案例5-获取Spring-Context\" class=\"headerlink\" title=\"案例5[获取Spring Context]\"></a>案例5[获取Spring Context]</h3><p>目的：展示获取Spring context 在获取bean， 然后调用函数</p>\n<ol>\n<li><p>使用tt命令获取到Spring Context</p>\n<ol>\n<li>tt是可以记录指定方法每次调用的入参和返回信息，并且能对这些不同的时间下调用进行观测</li>\n<li><a href=\"https://arthas.aliyun.com/doc/tt.html\">具体tt介绍</a></li>\n</ol>\n</li>\n<li><p><code>tt</code>命令捕获到了一个请求：：tt -t org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter invokeHandlerMethod</p>\n</li>\n<li><p>访问接口服务</p>\n<p><img src=\"/../../../images/image-20211125134509544.png\" alt=\"image-20211125134509544\"></p>\n</li>\n<li><p>使用tt命令从调用记录里获取到spring context：</p>\n<p>tt -i 1000 -w ‘target.getApplicationContext()’</p>\n</li>\n<li><p>获取springbean并调用函数</p>\n<p>tt -i 1000 -w ‘target.getApplicationContext().getBean(“helloWorldService”).getHelloMessage()’</p>\n<p><img src=\"/../../../images/image-20211125134709827.png\" alt=\"image-20211125134709827\"></p>\n</li>\n</ol>\n<h3 id=\"案例6-排查http请求返回401\"><a href=\"#案例6-排查http请求返回401\" class=\"headerlink\" title=\"案例6[排查http请求返回401]\"></a>案例6[排查http请求返回401]</h3><p>日常开发我们也会遇到401问题。如Something went wrong: 401 Unauthorized，我们现在想知道是哪个filter拦截了。怎么排查呢？</p>\n<ol>\n<li><p>跟踪所有的Filter函数</p>\n<p>trace javax.servlet.Fileter.* (trace和watch是一个监听命令)</p>\n<p>访问具体权限接口在terminal会打印filter内容</p>\n<p><img src=\"/../../../images/image-20211125135238722.png\" alt=\"image-20211125135238722\"></p>\n</li>\n<li><p>使用stack获取调用栈</p>\n<p>stack javax.servlet.http.HttpServletResponse sendError ‘params[0]&#x3D;&#x3D;401’</p>\n<p>访问权限接口</p>\n<p><img src=\"/../../../images/image-20211125135209283.png\" alt=\"image-20211125135209283\"></p>\n<p><img src=\"/../../../images/image-20211125135335952.png\" alt=\"image-20211125135335952\"><br>根据调用栈提示可以快速定位问题</p>\n</li>\n</ol>\n<h3 id=\"案例7-排查Http请求返回404\"><a href=\"#案例7-排查Http请求返回404\" class=\"headerlink\" title=\"案例7[排查Http请求返回404]\"></a>案例7[排查Http请求返回404]</h3><p>开发404常见，原因是资源找不到。那么到底是哪个servlet处理这个请求呢？</p>\n<ol>\n<li><p>跟踪所有的servlet函数</p>\n<p>trace javax.servlet.Servlet * &gt; &#x2F;tmp&#x2F;servlet.txt</p>\n<p>打开tmp文件夹中的servlet.txt查看</p>\n<p><img src=\"/../../../images/image-20211125135736470.png\" alt=\"image-20211125135736470\"></p>\n<p>可以定位到最终处理的是SpringFramework</p>\n</li>\n</ol>\n<h3 id=\"案例8-理解Spring-Boot应用的ClassLoader结构\"><a href=\"#案例8-理解Spring-Boot应用的ClassLoader结构\" class=\"headerlink\" title=\"案例8[理解Spring Boot应用的ClassLoader结构]\"></a>案例8[理解Spring Boot应用的ClassLoader结构]</h3><ol>\n<li><p>列出所有的ClassLoader</p>\n<p>classloader -l</p>\n</li>\n<li><p>列出上面的<code>org.apache.jasper.servlet.JasperLoader</code>加载的类：</p>\n<p>classloader -a –classLoaderClass org.apache.jasper.servlet.JasperLoader</p>\n<ul>\n<li>注：同ognl, 也可用<code>-c &lt;hashcode&gt;</code>而不用<code>--classLoaderClass</code>指定</li>\n</ul>\n</li>\n<li><p>反编译jsp代码</p>\n<p>jad org.apache.jsp.jsp.hello_jsp</p>\n</li>\n<li><p>查询ClassLoader树</p>\n<p>classloader -t</p>\n<p><img src=\"/../../../images/image-20211125140253114.png\" alt=\"image-20211125140253114\"></p>\n</li>\n<li><p>列出ClassLoader的urls</p>\n<p>比如上面查看到的spring LaunchedURLClassLoader的 hashcode是<code>1be6f5c3</code>，可以通过<code>-c</code>或者<code>--classLoaderClass</code>参数来列出它的所有urls：</p>\n<p>classloader –classLoaderClass</p>\n</li>\n<li><p>加载指定ClassLoader里的资源文件</p>\n<p>classloader –classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -r logback-spring.xml</p>\n</li>\n<li><p>尝试加载指定的类</p>\n<p>比如用上面的spring LaunchedURLClassLoader 尝试加载 <code>java.lang.String</code> ：</p>\n<p>classloader –classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader –load java.lang.String</p>\n</li>\n</ol>\n<h3 id=\"案例9-查询Top-N-线程\"><a href=\"#案例9-查询Top-N-线程\" class=\"headerlink\" title=\"案例9[查询Top N 线程]\"></a>案例9[查询Top N 线程]</h3><ol>\n<li><p>查询所有线程信息</p>\n<p>thread</p>\n</li>\n<li><p>查看具体线程的栈</p>\n<p>查询线程ID16的栈</p>\n<p>thread 16</p>\n</li>\n<li><p>查看CPU使用率top n 线程栈</p>\n<p>thread -n 3</p>\n<p>查询5秒内cpu使用率top n线程栈</p>\n<p>thread -n 3 -i 5000</p>\n</li>\n<li><p>查看线程是否有阻塞</p>\n<p>thread -b</p>\n</li>\n</ol>\n","categories":["排错"],"tags":["Java"]},{"title":"Docker搭建mysql主从复制","url":"/2022/04/17/Docker%E6%90%AD%E5%BB%BAmysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/","content":"<h3 id=\"一、通过docker拉去mysql镜像\"><a href=\"#一、通过docker拉去mysql镜像\" class=\"headerlink\" title=\"一、通过docker拉去mysql镜像\"></a>一、通过docker拉去mysql镜像</h3><ol>\n<li>docker pull mysql:5.7</li>\n</ol>\n<h3 id=\"二、启动主mysql服务\"><a href=\"#二、启动主mysql服务\" class=\"headerlink\" title=\"二、启动主mysql服务\"></a>二、启动主mysql服务</h3><ol>\n<li><p>启动主mysql 服务</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -p 3307:3306 --name mysql-master \\</span><br><span class=\"line\">-v /mydata/mysql-master/log:/var/log/mysql \\</span><br><span class=\"line\">-v /mydata/mysql-master/data:/var/lib/mysql \\</span><br><span class=\"line\">-v /mydata/mysql-master/conf:/etc/mysql \\</span><br><span class=\"line\">-e MYSQL_ROOT_PASSWORD=root  \\</span><br><span class=\"line\">-d mysql:5.7</span><br><span class=\"line\"></span><br><span class=\"line\">参数解释</span><br><span class=\"line\">\t-p 指定端口 映射端口:主机端口</span><br><span class=\"line\">\t--name 指定启动镜像别名</span><br><span class=\"line\">\t-v 挂载目录（数据卷）</span><br><span class=\"line\">\t-d 后台启动</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在mysql的配置文件夹<code>/mydata/mysql-master/conf</code>中创建一个配置文件<code>my.cnf</code>：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">1、进入目录 cd /mydata/mysql-master/conf</span><br><span class=\"line\">2、使用命令 vim my.cnf</span><br><span class=\"line\"></span><br><span class=\"line\">[mysqld]</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\"><span class=\"comment\"># 设置server_id，同一局域网中需要唯一</span></span></span><br><span class=\"line\">server_id=101</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\"><span class=\"comment\"># 指定不需要同步的数据库名称</span></span></span><br><span class=\"line\">binlog-ignore-db=mysql</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\"><span class=\"comment\"># 开启二进制日志功能</span></span></span><br><span class=\"line\">log-bin=mall-mysql-bin</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\"><span class=\"comment\"># 设置二进制日志使用内存大小（事务）</span></span></span><br><span class=\"line\">binlog_cache_size=1M</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\"><span class=\"comment\"># 设置使用的二进制日志格式（mixed,statement,row）</span></span></span><br><span class=\"line\">binlog_format=mixed</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\"><span class=\"comment\"># 二进制日志过期清理时间。默认值为0，表示不自动清理。</span></span></span><br><span class=\"line\">expire_logs_days=7</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\"><span class=\"comment\"># 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\"><span class=\"comment\"># 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span></span></span><br><span class=\"line\">slave_skip_errors=1062</span><br><span class=\"line\"></span><br><span class=\"line\">init_connect=&#x27;SET collation_connection = utf8_unicode_ci&#x27;</span><br><span class=\"line\">init_connect=&#x27;SET collation_connection = utf8_unicode_ci&#x27;</span><br><span class=\"line\">init_connect=&#x27;SET NAMES utf8&#x27;</span><br><span class=\"line\">character-set-server=utf8</span><br><span class=\"line\">collation-server=utf8_unicode_ci</span><br><span class=\"line\">skip-character-set-client-handshake</span><br><span class=\"line\">skip-name-resolve</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\"><span class=\"comment\"># 指定字符集</span></span></span><br><span class=\"line\">[client]</span><br><span class=\"line\">default-character-set=utf8</span><br><span class=\"line\">[mysql]</span><br><span class=\"line\">default-character-set=utf8</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>重启mysql-master实例：<font color=\"#FF0000\">docker restart mysql-master</font></p>\n</li>\n<li><p>进入mysql-master容器：<font color=\"#FF0000\">docker exec -it mysql-master &#x2F;bin&#x2F;bash</font></p>\n<p><img src=\"/../../../images/imagi-20210401113202243.png\" alt=\"image-20210401113202243\"></p>\n</li>\n<li><p>进入容器后输入mysql -uroot -proot</p>\n<p><img src=\"/../../../images/image-20210401113252684.png\" alt=\"image-20210401113252684\"></p>\n</li>\n<li><p>创建数据同步用户</p>\n<ol>\n<li><p>命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE USER &#x27;slave&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;123456&#x27;;</span><br><span class=\"line\">GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO &#x27;slave&#x27;@&#x27;%&#x27;;</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\"><span class=\"comment\"># 到时候创建的这个用户需要对应配置从服务器里面参数的master_user和master_password</span></span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><img src=\"/../../../images/image-20210401114807485.png\" alt=\"image-20210401114807485\"></p>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"三、-启动从mysql服务\"><a href=\"#三、-启动从mysql服务\" class=\"headerlink\" title=\"三、 启动从mysql服务\"></a>三、 启动从mysql服务</h3><ol>\n<li><p>服务启动</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -p 3308:3306 --name mysql-slave \\</span><br><span class=\"line\">-v /mydata/mysql-slave/log:/var/log/mysql \\</span><br><span class=\"line\">-v /mydata/mysql-slave/data:/var/lib/mysql \\</span><br><span class=\"line\">-v /mydata/mysql-slave/conf:/etc/mysql \\</span><br><span class=\"line\">-e MYSQL_ROOT_PASSWORD=root  \\</span><br><span class=\"line\">-d mysql:5.7</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在mysql的配置文件夹<code>/mydata/mysql-slave/conf</code>中创建一个配置文件<code>my.cnf</code>：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">1、进入目录 cd /mydata/mysql-master/conf</span><br><span class=\"line\">2、使用命令 vim my.cnf</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\"><span class=\"comment\"># 设置server_id，同一局域网中需要唯一</span></span></span><br><span class=\"line\">server_id=102</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\"><span class=\"comment\"># 指定不需要同步的数据库名称</span></span></span><br><span class=\"line\">binlog-ignore-db=mysql</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\"><span class=\"comment\"># 开启二进制日志功能，以备Slave作为其它数据库实例的Master时使用</span></span></span><br><span class=\"line\">log-bin=mall-mysql-slave1-bin</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\"><span class=\"comment\"># 设置二进制日志使用内存大小（事务）</span></span></span><br><span class=\"line\">binlog_cache_size=1M</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\"><span class=\"comment\"># 设置使用的二进制日志格式（mixed,statement,row）</span></span></span><br><span class=\"line\">binlog_format=mixed</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\"><span class=\"comment\"># 二进制日志过期清理时间。默认值为0，表示不自动清理。</span></span></span><br><span class=\"line\">expire_logs_days=7</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\"><span class=\"comment\"># 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\"><span class=\"comment\"># 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span></span></span><br><span class=\"line\">slave_skip_errors=1062</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\"><span class=\"comment\"># relay_log配置中继日志</span></span></span><br><span class=\"line\">relay_log=mall-mysql-relay-bin</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\"><span class=\"comment\"># log_slave_updates表示slave将复制事件写进自己的二进制日志</span></span></span><br><span class=\"line\">log_slave_updates=1</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\"><span class=\"comment\"># slave设置为只读（具有super权限的用户除外）</span></span></span><br><span class=\"line\">read_only=1</span><br><span class=\"line\"></span><br><span class=\"line\">init_connect=&#x27;SET collation_connection = utf8_unicode_ci&#x27;</span><br><span class=\"line\">init_connect=&#x27;SET collation_connection = utf8_unicode_ci&#x27;</span><br><span class=\"line\">init_connect=&#x27;SET NAMES utf8&#x27;</span><br><span class=\"line\">character-set-server=utf8</span><br><span class=\"line\">collation-server=utf8_unicode_ci</span><br><span class=\"line\">skip-character-set-client-handshake</span><br><span class=\"line\">skip-name-resolve</span><br><span class=\"line\"></span><br><span class=\"line\">[client]</span><br><span class=\"line\">default-character-set=utf8</span><br><span class=\"line\">[mysql]</span><br><span class=\"line\">default-character-set=utf8 </span><br></pre></td></tr></table></figure>\n</li>\n<li><p>重启mysql-slave实例：<font color=\"#FF0000\">docker restart mysql-slave</font></p>\n<ol>\n<li>查询主数据状态：<font color=\"#FF0000\">show master status</font></li>\n</ol>\n<p><img src=\"/../../../images/image-20210401114044535.png\" alt=\"image-20210401114044535\"></p>\n</li>\n<li><p>进入从mysql服务 <font color=\"#FF0000\">docker exec -it mysql-slave &#x2F;bin&#x2F;bash</font></p>\n</li>\n<li><p>连接mysql，输入</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">change master to master_host=&#x27;192.168.0.88&#x27;, master_user=&#x27;slave&#x27;, master_password=&#x27;123456&#x27;, master_port=3307, master_log_file=&#x27;mall-mysql-bin.000003&#x27;, master_log_pos=154, master_connect_retry=30;  </span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../../../images/image-20210401114456682.png\" alt=\"image-20210401114456682\"></p>\n<p>参数命令详解</p>\n<ol>\n<li>master_host：主数据库的IP地址；</li>\n<li>master_port：主数据库的运行端口；</li>\n<li>master_user：在主数据库创建的用于同步数据的用户账号；</li>\n<li>master_password：在主数据库创建的用于同步数据的用户密码；</li>\n<li>master_log_file：指定从数据库要复制数据的日志文件，通过查看主数据的状态，获取File参数；</li>\n<li>master_log_pos：指定从数据库从哪个位置开始复制数据，通过查看主数据的状态，获取Position参数；</li>\n<li>master_connect_retry：连接失败重试的时间间隔，单位为秒。</li>\n</ol>\n</li>\n<li><p>查询从数据库状态： <font color=\"#FF0000\">show slave status</font></p>\n<p><img src=\"/../../../images/image-20210401115118759.png\" alt=\"image-20210401115118759\"></p>\n<p>如果两个都为NO表示还没有开始同步，需要手动开启同步，使用命令：<font color=\"#FF0000\">start slave</font></p>\n</li>\n<li><p>测试的话，你可以在你的主库创建一个数据库test，然后在主从mysql客户端输入命令 ：<font color=\"#FF0000\">show databases</font></p>\n</li>\n</ol>\n<p>以上是搭建主从复制的简单流程</p>\n","tags":["运维"]},{"title":"Map中的computeIfAbsent方法的使用","url":"/2022/06/29/Map%E4%B8%AD%E7%9A%84computeIfAbsent%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"<h1 id=\"Map中的computeIfAbsent方法的使用\"><a href=\"#Map中的computeIfAbsent方法的使用\" class=\"headerlink\" title=\"Map中的computeIfAbsent方法的使用\"></a>Map中的computeIfAbsent方法的使用</h1><h3 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h3><p>今天在阅读代码时看到Map中的computeIfAbsent方法，最开始么有整明白computeIfAbsent方法。就去翻阅资料啦。Map中computeIfAbsent方法是java8新增的一个方法，方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">default</span> V <span class=\"title function_\">computeIfAbsent</span><span class=\"params\">(K key,</span></span><br><span class=\"line\"><span class=\"params\">            Function&lt;? <span class=\"built_in\">super</span> K, ? extends V&gt; mappingFunction)</span> &#123;</span><br><span class=\"line\">        Objects.requireNonNull(mappingFunction);</span><br><span class=\"line\">        V v;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((v = get(key)) == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            V newValue;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((newValue = mappingFunction.apply(key)) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                put(key, newValue);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> newValue;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> v;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>Function是一个<code>函数式接口</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">R <span class=\"title function_\">apply</span><span class=\"params\">(T t)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法首先判断map中是否存在指定的key值，如果不存在，会自动调用mappingFunction(key)计算key的value，然后将key &#x3D; value放入到缓存Map,java8会使用thread-safe的方式从cache中存取记录</p>\n<p>如果<code>mappingFunction(key)</code>返回的值为<code>null</code>或抛出异常，则不会有记录存入<code>map</code></p>\n<h3 id=\"二、代码示例\"><a href=\"#二、代码示例\" class=\"headerlink\" title=\"二、代码示例\"></a>二、代码示例</h3><ol>\n<li><p>示例一：computeIfAbsent基础用法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Map&lt;String, Integer&gt; prices = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">prices.put(<span class=\"string\">&quot;apple&quot;</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">prices.put(<span class=\"string\">&quot;banana&quot;</span>,<span class=\"number\">4</span>);</span><br><span class=\"line\">prices.put(<span class=\"string\">&quot;orange&quot;</span>,<span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">pear</span> <span class=\"operator\">=</span> prices.computeIfAbsent(<span class=\"string\">&quot;pear&quot;</span>, k -&gt; <span class=\"number\">10</span>);</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;pear price=&quot;</span> + pear);</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;update map&quot;</span> + prices);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出</span></span><br><span class=\"line\">pear price=<span class=\"number\">10</span></span><br><span class=\"line\">update map&#123;banana=<span class=\"number\">4</span>, orange=<span class=\"number\">10</span>, apple=<span class=\"number\">2</span>, pear=<span class=\"number\">10</span>&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>示例二：统计一个List中元素出现的个数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Map&lt;String, AtomicInteger&gt; counts = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">        List&lt;String&gt; list = Lists.newArrayList(<span class=\"string\">&quot;猫&quot;</span>, <span class=\"string\">&quot;狗&quot;</span>, <span class=\"string\">&quot;猫&quot;</span>, <span class=\"string\">&quot;狗&quot;</span>, <span class=\"string\">&quot;狗&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;狗&quot;</span>);</span><br><span class=\"line\">        list.forEach(str -&gt; counts.computeIfAbsent(str, k -&gt; <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicInteger</span>()).getAndIncrement());</span><br><span class=\"line\">        counts.forEach((k,v)-&gt; System.out.println(k + <span class=\"string\">&quot;:&quot;</span> + v));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出</span></span><br><span class=\"line\">狗:<span class=\"number\">4</span></span><br><span class=\"line\">猫:<span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>示例三：把0~9个数字进行归类，取模运算后，结果相同的数字放一起</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 没使用computeIfAbsent</span></span><br><span class=\"line\">Map&lt;Integer, List&lt;Integer&gt;&gt; unUseComputeIfAbsentMap = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> i % <span class=\"number\">5</span>;</span><br><span class=\"line\">  List&lt;Integer&gt; integers = unUseComputeIfAbsentMap.get(key);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (integers == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    integers = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">    unUseComputeIfAbsentMap.put(key, integers);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  integers.add(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;没使用computeIfAbsent&quot;</span> + unUseComputeIfAbsentMap);</span><br><span class=\"line\"><span class=\"comment\">// 使用computeIfAbsent</span></span><br><span class=\"line\">Map&lt;Integer, List&lt;Integer&gt;&gt; useComputeIfAbsentMap = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> i % <span class=\"number\">5</span>;</span><br><span class=\"line\">  useComputeIfAbsentMap.computeIfAbsent(key, k -&gt; <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;()).add(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;使用computeIfAbsent map&quot;</span> + useComputeIfAbsentMap);</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"三、性能检测\"><a href=\"#三、性能检测\" class=\"headerlink\" title=\"三、性能检测\"></a>三、性能检测</h3><ol>\n<li><p>普通实现方式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 普通的实现方式 普通方式使用大量的计算，存在性能问题. 并且计算量随着n的增加呈指数级增加，需要用到一些缓存策略，并且是线程安全的.</span></span><br><span class=\"line\"><span class=\"comment\">\t * </span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> n</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">fibonacci</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (n == <span class=\"number\">0</span> || n == <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> n;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;calculating Fibonacci(&quot;</span> + n + <span class=\"string\">&quot;)&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> fibonacci(n - <span class=\"number\">2</span>) + fibonacci(n - <span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出结果</span></span><br><span class=\"line\">calculating <span class=\"title function_\">Fibonacci</span><span class=\"params\">(<span class=\"number\">7</span>)</span></span><br><span class=\"line\">calculating <span class=\"title function_\">Fibonacci</span><span class=\"params\">(<span class=\"number\">5</span>)</span></span><br><span class=\"line\">calculating <span class=\"title function_\">Fibonacci</span><span class=\"params\">(<span class=\"number\">3</span>)</span></span><br><span class=\"line\">calculating <span class=\"title function_\">Fibonacci</span><span class=\"params\">(<span class=\"number\">2</span>)</span></span><br><span class=\"line\">calculating <span class=\"title function_\">Fibonacci</span><span class=\"params\">(<span class=\"number\">4</span>)</span></span><br><span class=\"line\">calculating <span class=\"title function_\">Fibonacci</span><span class=\"params\">(<span class=\"number\">2</span>)</span></span><br><span class=\"line\">calculating <span class=\"title function_\">Fibonacci</span><span class=\"params\">(<span class=\"number\">3</span>)</span></span><br><span class=\"line\">calculating <span class=\"title function_\">Fibonacci</span><span class=\"params\">(<span class=\"number\">2</span>)</span></span><br><span class=\"line\">calculating <span class=\"title function_\">Fibonacci</span><span class=\"params\">(<span class=\"number\">6</span>)</span></span><br><span class=\"line\">calculating <span class=\"title function_\">Fibonacci</span><span class=\"params\">(<span class=\"number\">4</span>)</span></span><br><span class=\"line\">calculating <span class=\"title function_\">Fibonacci</span><span class=\"params\">(<span class=\"number\">2</span>)</span></span><br><span class=\"line\">calculating <span class=\"title function_\">Fibonacci</span><span class=\"params\">(<span class=\"number\">3</span>)</span></span><br><span class=\"line\">calculating <span class=\"title function_\">Fibonacci</span><span class=\"params\">(<span class=\"number\">2</span>)</span></span><br><span class=\"line\">calculating <span class=\"title function_\">Fibonacci</span><span class=\"params\">(<span class=\"number\">5</span>)</span></span><br><span class=\"line\">calculating <span class=\"title function_\">Fibonacci</span><span class=\"params\">(<span class=\"number\">3</span>)</span></span><br><span class=\"line\">calculating <span class=\"title function_\">Fibonacci</span><span class=\"params\">(<span class=\"number\">2</span>)</span></span><br><span class=\"line\">calculating <span class=\"title function_\">Fibonacci</span><span class=\"params\">(<span class=\"number\">4</span>)</span></span><br><span class=\"line\">calculating <span class=\"title function_\">Fibonacci</span><span class=\"params\">(<span class=\"number\">2</span>)</span></span><br><span class=\"line\">calculating <span class=\"title function_\">Fibonacci</span><span class=\"params\">(<span class=\"number\">3</span>)</span></span><br><span class=\"line\">calculating <span class=\"title function_\">Fibonacci</span><span class=\"params\">(<span class=\"number\">2</span>)</span></span><br><span class=\"line\">Fibonacci(<span class=\"number\">7</span>) = <span class=\"number\">13</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Java7</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 在java7中的实现方式</span></span><br><span class=\"line\"><span class=\"comment\">\t * 在java7中，通过synchronized进行线程同步，检查缓存是否存在key对应的值，如果不存在才进行计算并放入缓存中</span></span><br><span class=\"line\"><span class=\"comment\">\t * 为了更好的性能，需要使用 double-checked locking，那样代码会更复杂</span></span><br><span class=\"line\"><span class=\"comment\">\t * </span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> n</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">fibonacciJava7</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (n == <span class=\"number\">0</span> || n == <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> n;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">Integer</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> cache.get(n);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (result == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">synchronized</span> (cache) &#123;</span><br><span class=\"line\">\t\t\t\tresult = cache.get(n);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (result == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\tSystem.out.println(<span class=\"string\">&quot;calculating FibonacciJava7(&quot;</span> + n + <span class=\"string\">&quot;)&quot;</span>);</span><br><span class=\"line\">\t\t\t\t\tresult = fibonacciJava7(n - <span class=\"number\">2</span>) + fibonacciJava7(n - <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t\t\t\tcache.put(n, result);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> result;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"comment\">// 输出结果</span></span><br><span class=\"line\">FibonacciJava7(<span class=\"number\">7</span>) = <span class=\"number\">13</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Java8</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 采用java8的本地缓存方式 如果缓存MAP中不存在指定key的值，会自动调用mappingFunction(key)计算key的value</span></span><br><span class=\"line\"><span class=\"comment\">\t * 然后将key = value放入到缓存Map,java8会使用thread-safe的方式从cache中存取记录</span></span><br><span class=\"line\"><span class=\"comment\">\t * </span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> n</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">fibonacciJava8</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> cache.computeIfAbsent(n, (key) -&gt; &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">&quot;calculating FibonacciJava8 &quot;</span> + n);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> fibonacciJava8(n - <span class=\"number\">2</span>) + fibonacciJava8(n - <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">calculating FibonacciJava8 <span class=\"number\">7</span></span><br><span class=\"line\">calculating FibonacciJava8 <span class=\"number\">5</span></span><br><span class=\"line\">calculating FibonacciJava8 <span class=\"number\">3</span></span><br><span class=\"line\">calculating FibonacciJava8 <span class=\"number\">2</span></span><br><span class=\"line\">calculating FibonacciJava8 <span class=\"number\">4</span></span><br><span class=\"line\">calculating FibonacciJava8 <span class=\"number\">6</span></span><br><span class=\"line\">FibonacciJava8(<span class=\"number\">7</span>) = <span class=\"number\">13</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><a href=\"http://www.manongjc.com/detail/18-exbxxblysbloqcn.html\">参考地址</a></p>\n","categories":["Java"],"tags":["Map"]},{"title":"jdk命令工具的使用","url":"/2022/04/17/jdk%E5%91%BD%E4%BB%A4%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"<h1 id=\"常见jdk工具的使用\"><a href=\"#常见jdk工具的使用\" class=\"headerlink\" title=\"常见jdk工具的使用\"></a>常见jdk工具的使用</h1><h3 id=\"一、jps\"><a href=\"#一、jps\" class=\"headerlink\" title=\"一、jps\"></a>一、jps</h3><ol>\n<li><p>作用：列出正在运行的虚拟机进程，并显示虚拟机执行主类函数所在的类名称以及进程的本地虚拟机唯一ID。</p>\n</li>\n<li><p>命令格式：jps [options] [hostid]</p>\n</li>\n<li><p>参数解释：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">-q 显示进程ID</span><br><span class=\"line\">-m 显示进程id，主类名，以及传入main方法的参数</span><br><span class=\"line\">-l 显示进程id 主类名</span><br><span class=\"line\">-v 显示进程id，主类名称，以及传JVM的参数</span><br><span class=\"line\">-V 显示进程id 主类名</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"二、jstat\"><a href=\"#二、jstat\" class=\"headerlink\" title=\"二、jstat\"></a>二、jstat</h3><ol>\n<li><p>作用：监视虚拟机各种运行状态信息，可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据</p>\n</li>\n<li><p>命令格式：jstat [options vmid [interval[count]]]</p>\n</li>\n<li><p>参数解释：</p>\n<ol>\n<li><p>第一个参数options：代表用户希望查询的虚拟机信息，主要分为3类：类装载、垃圾收集和运行编译状况，具体参数如下</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">-class 显示有关类加载器行为的统计信息</span><br><span class=\"line\">  \t输出参数详解：Loaded：已加载的类数 Bytes：加载的kb数 Unloaded：卸载的类数 Bytes：卸载的kb数</span><br><span class=\"line\">-compiler：显示有关java Hotspot VM即时编译器行为的统计信息</span><br><span class=\"line\">  输出参数详解：Compiled：执行编译任务数 Failed：编译任务数失败 Invalid：无效的编译任务数 Time：执行编译任务花费的时间 FailedType：上次失败编译的编译类型 FailedMethos：上次失败编译的类名和方法</span><br><span class=\"line\">-gc：显示有关垃圾收集堆行为的统计信息</span><br><span class=\"line\">-gccapacity：显示有关各个垃圾回收代容量及其相应空间的统计信息</span><br><span class=\"line\">-gccause：显示有关垃圾收集统计信息（同-gcutil）,以及上一次和当前垃圾收集事件的原因</span><br><span class=\"line\">-gcnew：显示新生代行为的统计信息</span><br><span class=\"line\">-gcnewcapacity：显示有关新生代大小机器相应的统计信息</span><br><span class=\"line\">-gcold：显示有关老年代行为的统计信息和元空间统计信息</span><br><span class=\"line\">-gcoldcapacity：显示有关老年代大小的统计</span><br><span class=\"line\">-gcmetacapacity：显示有关元空间大小的统计信息</span><br><span class=\"line\">-gcutil：显示有关垃圾收集统计信息</span><br><span class=\"line\">  输出参数详解：S0：幸存者空间0利用率占该空间当前容量的百分比 S1:幸存者空间1利用率占空间当前容量的百分比 E:Eden空间利用率占空间当前容量的百分比 O:老年代利用率占空间当前容量的百分比 M:元空间利用率占用当前容量的百分比 CCS:压缩的类空间利用率，百分比展示 YGC：新生代GC事件的数量 YGCT：新生代垃圾回收的时间 FGC：完整GC事件的数量 FGCT：完整的垃圾收集时间 GCT：总的垃圾收集时间</span><br><span class=\"line\">-printcompilation：显示java HotSpot VM编译方法的统计信息</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>第二个参数vmid：如果本地虚拟机进程，vmid和本地虚拟机唯一ID是一致的，如果是远程虚拟机进程，那么vmid的格式是：protocol:lvmid[@hostname[:port]&#x2F;servername]</p>\n</li>\n<li><p>第三个参数：interval</p>\n<ol>\n<li>采样间隔，单位为秒或者毫秒</li>\n<li>指定后，jstat 命令将在每个间隔产生其输出</li>\n</ol>\n</li>\n<li><p>第四个参数：count</p>\n<ol>\n<li>采集样本的数量</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"三、Jinfo\"><a href=\"#三、Jinfo\" class=\"headerlink\" title=\"三、Jinfo\"></a>三、Jinfo</h3><ol>\n<li><p>作用：实时查看和调整虚拟机各项参数</p>\n</li>\n<li><p>命令格式：jinfo [options] <pid></p>\n</li>\n<li><p>参数解释：</p>\n<ol>\n<li><p>第一个参数</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">no option：输出全部参数和系统属性</span><br><span class=\"line\">-flag name ：输出对应名称的参数</span><br><span class=\"line\">-flag [+ | -]name:开启或者关闭对应名称的参数</span><br><span class=\"line\">-flag name=value：设定对应名称的参数</span><br><span class=\"line\">-flags：输出全部的参数</span><br><span class=\"line\">-sysprops：输出系统属性</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>举例</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">命令：jinfo pid</span><br><span class=\"line\">描述：输出当前jvm进程的全部参数和系统属性</span><br><span class=\"line\"></span><br><span class=\"line\">命令：jinfo -flag PrintGc pid</span><br><span class=\"line\">描述：输出虚拟机参数PrintGc的值</span><br><span class=\"line\"></span><br><span class=\"line\">命令：jinfo -flags pid</span><br><span class=\"line\">描述：输入虚拟机全部参数</span><br><span class=\"line\">  </span><br><span class=\"line\">命令：jinfo -flag [+|-]PrintGC pid</span><br><span class=\"line\">描述：开启PrintGC参数</span><br><span class=\"line\">  </span><br><span class=\"line\">命令：jinfo -flag HeapDumpPath pid</span><br><span class=\"line\">描述：查询dump文件目录位置</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ol>\n<h3 id=\"四、jmap\"><a href=\"#四、jmap\" class=\"headerlink\" title=\"四、jmap\"></a>四、jmap</h3><ol>\n<li><p>作用：是一个多功能命令，它可以生成java程序的dump文件，也可以查看堆内对象信息、查看ClassLoader的信息以及finalizer队列</p>\n</li>\n<li><p>命令格式：jmap [options] <pid></p>\n</li>\n<li><p>参数解释：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">no option :查看进程内存映像信息，类似solaris pmap命令</span><br><span class=\"line\">heap：超现实Java堆详细信息</span><br><span class=\"line\">histo[live]：显示堆对象的统计信息</span><br><span class=\"line\">clstats:打印类加载器信息</span><br><span class=\"line\">finalizerinfo：显示F-queue队列等待Finalizer线程执行finalizer方法的对象</span><br><span class=\"line\">dump&lt;dump-options&gt;:生成堆转储快照</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>举例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">命令：jmap pid</span><br><span class=\"line\">描述：查看进程的内存映像信息</span><br><span class=\"line\">使用不带选项参数的jmap打印共享对象映射，将会打印目标虚拟机中加载的每个共享对象的起始地址、映射大小以及共享对象文件的路径全称</span><br><span class=\"line\"></span><br><span class=\"line\">命令：jmap -heap pid</span><br><span class=\"line\">描述：显示java堆详细信息</span><br><span class=\"line\">打印一个堆的摘要信息，包括使用的GC算法、堆配置信息和各内存区域内存使用信息</span><br><span class=\"line\"></span><br><span class=\"line\">命令：jmap -histo pid</span><br><span class=\"line\">描述：显示堆中对象的统计信息</span><br><span class=\"line\">其中包括每个java类，对象数量、内存大小、完全限定的类名、打印的虚拟机内部类名将会带有一个‘*’前缀。如果制定了live子选项，则只会计算活动的对象</span><br><span class=\"line\"></span><br><span class=\"line\">命令：jmap -clstats pid</span><br><span class=\"line\">描述：打印类加载器的信息</span><br><span class=\"line\">-clstats是permstat的替代方案，在JDK8之前，-permstat用来打印类加载器的数据</span><br><span class=\"line\">打印Java堆内存的永久保存区域的类加载器的智能统计信息，对于每个类加载器而言，他的名称活跃度地址、父类加载器，它所加载的类的数量和大小都会被打印</span><br><span class=\"line\"></span><br><span class=\"line\">命令：jmap -finalizerinfo pid</span><br><span class=\"line\">描述：打印等待终结的对象信息</span><br><span class=\"line\">Number of objects pending for finalizerinfo：0说明当前F-QUEUE队列中没有等待finalizer线程执行finalizer方法的对象</span><br><span class=\"line\"></span><br><span class=\"line\">命令：jmap -dump:live,format=b,file=jmap.bin &lt;pid&gt;</span><br><span class=\"line\">描述：生成堆转存储快照dump文件</span><br><span class=\"line\">以二进制格式转存储java堆到制定filename的文件中。live子选项是可选。如果制定live子选项，堆中只有活动的对象会被存储，想要浏览heap dump，你可以使用jhat命令</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"五、jhat\"><a href=\"#五、jhat\" class=\"headerlink\" title=\"五、jhat\"></a>五、jhat</h3><ol>\n<li><p>作用：与jmap搭配使用来分析jmap生产的堆转存储快照。jhat内置一个微型的HTTP&#x2F;HTML服务器，生产dump文件的分析结果后，可以在浏览器中查看。一般不会在部署应用程序服务器直接分析，。替代工具：VisualVM、Ecplise Memory Analyzer、IBM HeapAnalyzer等工具</p>\n</li>\n<li><p>命令格式：jhat [options] 堆转储文件</p>\n</li>\n<li><p>参数解释</p>\n<ol>\n<li><p>第一个参数：options</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[-stack &lt;bool&gt;]:开关对象分配调用栈跟踪(tracking object allocation call stack)。如果分配位置信息在堆转储中不可用，则必须将此标志设置为false，默认值为true</span><br><span class=\"line\">[-refs &lt;bool&gt;]:开关对象引用跟踪(tracking of references to objects)。默认值为true，默认情况下返回指针是指向其他特定对象的对象，如反向链接或输入引用（references or incoming references)，会统计计算堆中的所有对象</span><br><span class=\"line\">[-port&lt;port&gt;]:设置jhat Httpserver的端口号</span><br><span class=\"line\">[-exclude &lt;file&gt;]:指定对象查询是需要排除的数据成员列表文件(列出应从可访问对象查询中排除的数据成员文件)。例如，如果文件列列出了java.lang.String.value，那么当从某个特定对象Object o 计算可达到的对象列表时，引用路径涉及java.lang.String.value的都会被排除</span><br><span class=\"line\">[-baseline&lt;file&gt;]:指定一个基准堆转储(baseline heap dump)。在两个heap dumps中有相同objectId的对象会被标记为不是新的(maked as not being new)。其他对象被标记新的。在比较两个不用的堆转储时很有用</span><br><span class=\"line\">[-debug &lt;file&gt;] ：设置debug级别。0表示不输出调试信息。值越大则表示输出更详细的debug信息</span><br><span class=\"line\">[-version ]：启动后只显示版本信息就退出</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>第二个参数：堆转储文件</p>\n<ol>\n<li>要浏览的java二进制堆转储文件</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"六、-jstack\"><a href=\"#六、-jstack\" class=\"headerlink\" title=\"六、 jstack\"></a>六、 jstack</h3><ol>\n<li>作用：查看或者导出Java应用程序中线程堆栈信息</li>\n<li>线程快照是当前java虚拟机内每一条线程正在执行的方法堆栈集合，生成线程快照的目的是定位线程出现长时间停顿的原因，如线程死锁、死循环、长时间等待外部资源等。线程出现停顿的时候通过jstack来查看线程调用堆栈，就可以知道没有响应的线程到底在后台做了什么事情，或者等待什么资源。如果Java程序崩溃生成core文件，jstack工具可以用来获取core文件的java stack 和native stack的信息，从而可以轻松知道java程序是如果崩溃和在程序何处发生问题。另外，jstack工具还可以附属到正在运行的java程序中，看到当时运行java程序的javastack和native stack的信息</li>\n<li>命令格式：jstack [options] <pid></li>\n<li>参数解释<ol>\n<li>-F：当线程挂起，使用jstack -l pid请求不被响应时，强制输出线程堆栈</li>\n<li>-l：除堆栈外，显示关于锁的附加信息例如：ownable synchronizers</li>\n<li>-m：可以同时输出java以及c&#x2F;c++的堆栈信息</li>\n<li>演示：<ol>\n<li>CPU过高：<ul>\n<li>使用Process Explorer工具，找到CPU占用率高的进程id</li>\n<li>右击该进程，查看属性。在thread选项卡中，找到CPU占用率高的线程id</li>\n<li>把线程id转换成16禁止</li>\n<li>使用jstack -l pid 查看进程的线程快照</li>\n<li>在线程快照中指定的线程，并分析代码</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n","categories":["jvm"],"tags":["Java"]},{"title":"tree命令的使用","url":"/2022/06/29/tree%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"<h3 id=\"一、参数详解\"><a href=\"#一、参数详解\" class=\"headerlink\" title=\"一、参数详解\"></a>一、参数详解</h3><ol>\n<li>-a 显示所有文件和目录。</li>\n<li>-A 使用ASNI绘图字符显示树状图而非以ASCII字符组合。</li>\n<li>-C 在文件和目录清单加上色彩，便于区分各种类型。</li>\n<li>-d 显示目录名称而非内容。</li>\n<li>-D 列出文件或目录的更改时间。</li>\n<li>-f 在每个文件或目录之前，显示完整的相对路径名称。</li>\n<li>-F 在执行文件，目录，Socket，符号连接，管道名称名称，各自加上”*”,”&#x2F;”,”&#x3D;”,”@”,”|”号。</li>\n<li>-g 列出文件或目录的所属群组名称，没有对应的名称时，则显示群组识别码。</li>\n<li>-i 不以阶梯状列出文件或目录名称。</li>\n<li>-I 不显示符合范本样式的文件或目录名称。</li>\n<li>-l 如遇到性质为符号连接的目录，直接列出该连接所指向的原始目录。</li>\n<li>-n 不在文件和目录清单加上色彩。</li>\n<li>-N 直接列出文件和目录名称，包括控制字符。</li>\n<li>-p 列出权限标示。</li>\n<li>-P 只显示符合范本样式的文件或目录名称。</li>\n<li>-q 用”?”号取代控制字符，列出文件和目录名称。</li>\n<li>-s 列出文件或目录大小。</li>\n<li>-t 用文件和目录的更改时间排序。</li>\n<li>-u 列出文件或目录的拥有者名称，没有对应的名称时，则显示用户识别码。</li>\n<li>-x 将范围局限在现行的文件系统中，若指定目录下的某些子目录，其存放于另一个文件系统上，则将该子目录予以排除在寻找范围外。</li>\n</ol>\n","categories":["linux"],"tags":["linux"]},{"title":"validator中三种注解的区别","url":"/2022/05/03/validator%E4%B8%AD%E4%B8%89%E7%A7%8D%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"<h1 id=\"NotEmpty、-NotBlank、-NotNull三种注解的区别\"><a href=\"#NotEmpty、-NotBlank、-NotNull三种注解的区别\" class=\"headerlink\" title=\"@NotEmpty、@NotBlank、@NotNull三种注解的区别\"></a>@NotEmpty、@NotBlank、@NotNull三种注解的区别</h1><h3 id=\"一、-NotEmpty\"><a href=\"#一、-NotEmpty\" class=\"headerlink\" title=\"一、@NotEmpty\"></a>一、@NotEmpty</h3><ol>\n<li>用在集合类上面</li>\n<li>加了@NotEmpty的String类、Collection、Map、数组，是不能为null或者长度为0的(String Collection Map的isEmpty()方法)</li>\n</ol>\n<h3 id=\"二、-NotNull\"><a href=\"#二、-NotNull\" class=\"headerlink\" title=\"二、@NotNull\"></a>二、@NotNull</h3><ol>\n<li>不能为null，但可以为empty,没有Size的约束</li>\n</ol>\n<h3 id=\"三、-NotBlank\"><a href=\"#三、-NotBlank\" class=\"headerlink\" title=\"三、@NotBlank\"></a>三、@NotBlank</h3><ol>\n<li>只用于String,不能为null，而且调用trim()后，长度必须大于0</li>\n</ol>\n","categories":["注解"],"tags":["Java"]},{"title":"常见的HTTP状态码","url":"/2022/05/14/%E5%B8%B8%E8%A7%81%E7%9A%84HTTP%E7%8A%B6%E6%80%81%E7%A0%81/","content":"<h1 id=\"常见的HTTP状态码\"><a href=\"#常见的HTTP状态码\" class=\"headerlink\" title=\"常见的HTTP状态码\"></a>常见的HTTP状态码</h1><h3 id=\"一、2开头-（请求成功）表示成功处理了请求的状态代码。\"><a href=\"#一、2开头-（请求成功）表示成功处理了请求的状态代码。\" class=\"headerlink\" title=\"一、2开头 （请求成功）表示成功处理了请求的状态代码。\"></a>一、2开头 （请求成功）表示成功处理了请求的状态代码。</h3><ol>\n<li>200  （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 </li>\n<li>201  （已创建） 请求成功并且服务器创建了新的资源。 </li>\n<li>202  （已接受） 服务器已接受请求，但尚未处理。 </li>\n<li>203  （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。 </li>\n<li>204  （无内容） 服务器成功处理了请求，但没有返回任何内容。 </li>\n<li>205  （重置内容） 服务器成功处理了请求，但没有返回任何内容。</li>\n<li>206  （部分内容） 服务器成功处理了部分 GET 请求。</li>\n</ol>\n<h3 id=\"二、3开头-（请求被重定向）表示要完成请求，需要进一步操作。-通常，这些状态代码用来重定向。\"><a href=\"#二、3开头-（请求被重定向）表示要完成请求，需要进一步操作。-通常，这些状态代码用来重定向。\" class=\"headerlink\" title=\"二、3开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。\"></a>二、3开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</h3><ol>\n<li>300  （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 </li>\n<li>301  （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</li>\n<li>302  （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</li>\n<li>303  （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。</li>\n<li>304  （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 </li>\n<li>305  （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。 </li>\n<li>307  （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</li>\n</ol>\n<h3 id=\"三、4开头-（请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。\"><a href=\"#三、4开头-（请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。\" class=\"headerlink\" title=\"三、4开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。\"></a>三、4开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。</h3><ol>\n<li>400  （错误请求） 服务器不理解请求的语法。 </li>\n<li>401  （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 </li>\n<li>403  （禁止） 服务器拒绝请求。</li>\n<li>404  （未找到） 服务器找不到请求的网页。</li>\n<li>405  （方法禁用） 禁用请求中指定的方法。 </li>\n<li>406  （不接受） 无法使用请求的内容特性响应请求的网页。 </li>\n<li>407  （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。</li>\n<li>408  （请求超时） 服务器等候请求时发生超时。 </li>\n<li>409  （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 </li>\n<li>410  （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。 </li>\n<li>411  （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。 </li>\n<li>412  （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。 </li>\n<li>413  （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 </li>\n<li>414  （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。 </li>\n<li>415  （不支持的媒体类型） 请求的格式不受请求页面的支持。 </li>\n<li>416  （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。 </li>\n<li>417  （未满足期望值） 服务器未满足”期望”请求标头字段的要求。</li>\n</ol>\n<h3 id=\"四、5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。-这些错误可能是服务器本身的错误，而不是请求出错。\"><a href=\"#四、5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。-这些错误可能是服务器本身的错误，而不是请求出错。\" class=\"headerlink\" title=\"四、5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。\"></a>四、5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</h3><ol>\n<li>500  （服务器内部错误） 服务器遇到错误，无法完成请求。 </li>\n<li>501  （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 </li>\n<li>502  （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。 </li>\n<li>503  （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 </li>\n<li>504  （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 </li>\n<li>505  （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。</li>\n</ol>\n","categories":["http"],"tags":["java"]}]